from datetime import datetime

from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, ForeignKey, Table, Index
from sqlalchemy import or_, func, select, exists
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.ext.hybrid import hybrid_method
from sqlalchemy.orm import relationship, backref, aliased
from sqlalchemy.sql import column

from libs.objects import Config

Base = declarative_base()
ADMIN_USERS = Config('api.conf').api.admins.split(",")

association_table = Table('association', Base.metadata,
                          Column('tag_id', Integer, ForeignKey('tag.id')),
                          Column('malware_id', Integer, ForeignKey('malware.id'))
                          )

malware_src = Table('malware_src', Base.metadata,
                    Column('m', Integer, ForeignKey('malware.id')),
                    Column('s', Integer, ForeignKey('source.id')),
                    extend_existing=True
                    )

malware_via = Table('malware_via', Base.metadata,
                    Column('m', Integer, ForeignKey('malware.id')),
                    Column('via', Integer, ForeignKey('via.id')),
                    extend_existing=True
                    )

xrefs = Table('xrefs', Base.metadata,
              Column('parent', Integer, ForeignKey('malware.id')),
              Column('child', Integer, ForeignKey('malware.id')),
              extend_existing=True
              )


class VTComment(Base):
    __tablename__ = 'vtcomms'
    __table_args__ = {'extend_existing': True}

    id = Column('id', Integer, primary_key=True)
    hash = Column(String(64), nullable=False, index=True)
    cmnt = Column(Text(), nullable=True)
    date = Column(DateTime(timezone=False), default=datetime.utcnow, nullable=False)
    user = Column(Text(), nullable=True)
    type = Column(Text(), nullable=True)


class Cuckoo(Base):
    __tablename__ = 'cuckoo'
    __table_args__ = {'extend_existing': True}

    id = Column('cuckoo_id', Integer)
    m = Column('mid', Integer, ForeignKey('malware.id'))
    __mapper_args__ = {"primary_key": (id, m)}

    def __init__(self, id):
        self.id = id


class _Config(Base):
    __tablename__ = 'ripper'
    __table_args__ = {'extend_existing': True}

    id = Column('id', Integer, primary_key=True)
    hash = Column('mongo_id', String(32), index=True, nullable=False, unique=True)
    mlwr = relationship('Malware', backref="_Config")

    def __init__(self, hash):
        self.hash = hash


class Source(Base):
    __tablename__ = 'source'
    __table_args__ = {'extend_existing': True}
    id = Column('id', Integer(), primary_key=True)
    source = Column('source', Text(), nullable=False)

    def __init__(self, src):
        self.source = src


class Via(Base):
    __tablename__ = 'via'
    __table_args__ = {'extend_existing': True}
    id = Column('id', Integer(), primary_key=True)
    via = Column('via', String(256), nullable=False)
    mlwr = relationship('Malware',
                        secondary=malware_via,
                        backref='malware')

    def __init__(self, via):
        self.via = via

    def __eq__(self, v):
        return self.via == v

    def __getitem__(self):
        return self.via


class Tag(Base):
    __tablename__ = "tag"

    id = Column(Integer(), primary_key=True)
    tag = Column(String(255), nullable=False, unique=True, index=True)

    def to_dict(self):
        row_dict = {}
        for column in self.__table__.columns:
            value = getattr(self, column.name)
            row_dict[column.name] = value

        return row_dict

    def __repr__(self):
        return "<Tag ('%s','%s'>" % (self.id, self.tag)

    def __init__(self, tag):
        self.tag = tag


class Malware(Base):
    __tablename__ = "malware"

    id = Column(Integer(), primary_key=True)
    file_name = Column(String(255), nullable=True)
    file_size = Column(Integer(), nullable=False)
    file_type = Column(Text(), nullable=True)
    md5 = Column(String(32), nullable=False, index=True)
    crc32 = Column(String(8), nullable=False)
    sha1 = Column(String(40), nullable=False)
    sha256 = Column(String(64), nullable=False, index=True)
    sha512 = Column(String(128), nullable=False)
    ssdeep = Column(String(255), nullable=True)
    created_at = Column(DateTime(timezone=False), default=datetime.utcnow, nullable=False)
    sharable = Column(Boolean(), default=True)
    comment = Column(Text(), nullable=True)

    tag = relationship(Tag,
                       secondary=association_table,
                       backref="malware")
    via = relationship(Via,
                       secondary=malware_via,
                       backref="malware")
    source = relationship(Source,
                          secondary=malware_src,
                          backref="malware")

    children = relationship('Malware', secondary=xrefs,
                            primaryjoin=xrefs.c.parent == id,
                            secondaryjoin=xrefs.c.child == id,
                            backref="parent"
                            )
    config_id = Column(Integer, ForeignKey('ripper.id'), nullable=True)
    config = relationship(_Config, backref=backref("Malware", uselist=False, cascade="save-update"))
    cuckoo = relationship(Cuckoo)
    __table_args__ = (Index("hash_index",
                            "md5",
                            "crc32",
                            "sha1",
                            "sha256",
                            "sha512",
                            unique=True),)

    def to_dict(self):
        row_dict = {}
        for column in self.__table__.columns:
            value = getattr(self, column.name)
            row_dict[column.name] = value

        return row_dict

    def __repr__(self):
        return "<Malware('%s','%s')>" % (self.id, self.md5)

    def __init__(self,
                 md5,
                 crc32,
                 sha1,
                 sha256,
                 sha512,
                 file_size,
                 file_type=None,
                 ssdeep=None,
                 file_name=None, source=None, via=None, comment=None, sharable=True):
        self.md5 = md5
        self.sha1 = sha1
        self.crc32 = crc32
        self.sha256 = sha256
        self.sha512 = sha512
        self.file_size = file_size
        self.file_type = file_type
        self.ssdeep = ssdeep
        self.file_name = file_name
        self.comment = comment
        self.sharable = sharable
        self.x_alias = None

    @property
    def tags(self):
        r = map(lambda x: x.tag, self.tag)
        return r

    @hybrid_method
    def get_xrefs(self, direction):
        def worker(m, r):
            for p in getattr(m, direction):
                if p in r:
                    continue

                r.add(p)
                r = r.union(worker(p, r))
            return r

        return worker(self, set())

    @get_xrefs.expression
    def get_xrefs(self, t0, t1):
        xr = func.get_xrefs(t0, t1, '123')
        ml = self.x_alias or aliased(Malware, name='ml')
        j = xr.join(ml, column('mid') == ml.id)
        return select([ml]).select_from(j)

    @hybrid_method
    def ancestors(self):
        return self.get_xrefs('parent')

    @hybrid_method
    def descendants(self):
        return self.get_xrefs('children')

    @descendants.expression
    def descendants(self):
        return self.get_xrefs('parent', 'child')

    @ancestors.expression
    def ancestors(self):
        return self.get_xrefs('child', 'parent')

    @hybrid_method
    def _is_sharable(self, user):
        return user in ADMIN_USERS or self.sharable

    @hybrid_method
    def flat_is_sharable(self, user):
        return self._is_sharable(user) or user in self.via

    @flat_is_sharable.expression
    def flat_is_sharable(self, user):
        return or_(self._is_sharable(user), self.via.any(Via.via == user))

    @hybrid_method
    def is_sharable(self, user):
        return self.flat_is_sharable(user) or any(map(lambda m: m.flat_is_sharable(user), self.ancestors()))

    @is_sharable.expression
    def is_sharable(self, user):
        self.x_alias = aliased(Malware, name='ml')
        return or_(self.flat_is_sharable(user), exists(self.ancestors().where(self.x_alias.flat_is_sharable(user))))
