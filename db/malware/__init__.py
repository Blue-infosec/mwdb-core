import enum
from sqlalchemy import and_, create_engine
from sqlalchemy.exc import SQLAlchemyError, IntegrityError
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import NullPool
from sqlalchemy.sql.expression import desc

import query
from db.malware.models import *
from db.malware.models import _Config
from db.malware.query import MalwareQuery
from libs.objects import File, Singleton

InsertRet = enum.IntEnum('InsertRet', 'ok duplicate error')


class Database:
    __metaclass__ = Singleton

    def __init__(self, cfg='api.conf'):
        self.engine = create_engine(Config(cfg).api.database, poolclass=NullPool)
        self.engine.echo = False
        self.engine.pool_timeout = 60

        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
        self._session = None
        self.user = None

    def set_user(self, user):
        self.user = user

    def __del__(self):
        self.engine.dispose()

    def add(self, obj, file_name, tags=None, src=None, via=None, comment='', sharable=True):
        session = self.session  # Session()
        exists = False
        if isinstance(obj, File):
            try:
                malware_entry = Malware(md5=obj.get_md5(),
                                        crc32=obj.get_crc32(),
                                        sha1=obj.get_sha1(),
                                        sha256=obj.get_sha256(),
                                        sha512=obj.get_sha512(),
                                        file_size=obj.get_size(),
                                        file_type=obj.get_type(),
                                        ssdeep=obj.get_ssdeep(),
                                        file_name=file_name, sharable=sharable, comment=comment)
                session.add(malware_entry)
                session.commit()
            except IntegrityError:
                session.rollback()
                malware_entry = session.query(Malware).filter(Malware.md5 == obj.get_md5()).first()
                exists = True
            except SQLAlchemyError:
                session.rollback()
                return (InsertRet.error, None)

        if via:
            for v in via.split(','):
                try:
                    malware_entry.via.append(Via(v))
                    session.commit()
                except IntegrityError as e:
                    session.rollback()
                try:
                    malware_entry.via.append(session.query(Via).filter(Via.via == v).first())
                    session.commit()
                except SQLAlchemyError:
                    session.rollback()

        if src:
            self.add_source(malware_entry, src)

        if tags:
            self.tags_append(malware_entry, tags)

        return (InsertRet.duplicate if exists else InsertRet.ok, malware_entry)

    def add_source(self, m, src):
        if issubclass(type(m), basestring):
            malware_entry = self.find_via_hash(m)
        else:
            malware_entry = m

        try:
            malware_entry.source.append(Source(src))
            self.session.commit()
        except IntegrityError as e:
            self.session.rollback()

        try:
            malware_entry.source.append(self.session.query(Source).filter(Source.source == src).first())
            self.session.commit()
        except SQLAlchemyError:
            self.session.rollback()

    def tags_append(self, m, tags):
        tags = tags.strip()
        if "," in tags:
            tags = tags.split(",")
        else:
            tags = tags.split(" ")

        for tag in tags:
            tag = tag.strip().lower()
            if tag == "":
                continue

            self.tag_insert(m, tag)

    def tag_insert(self, m, tag):

        try:
            m.tag.append(Tag(tag))
            self.session.commit()
            return

        except IntegrityError as e:
            self.session.rollback()

        try:
            m.tag.append(self.session.query(Tag).filter(Tag.tag == tag).first())
            self.session.commit()
        except SQLAlchemyError:
            self.session.rollback()

    @property
    def session(self):
        if not self._session:
            self._session = self.Session()
        return self._session

    def recent(self, cnt=100):
        return self.session.query(Malware).filter(Malware.is_sharable(self.user)).order_by(
                    desc(Malware.created_at)).limit(cnt).all()

    def find_via_hash(self, has):
        if has and not issubclass(type(has), basestring):
            ### this is allready an object
            return has

        lhash = len(has)
        has = has.lower()
        if lhash == 32:
            return self.find_md5(has)
        elif lhash == 40:
            return self.find_sha1(has)
        elif lhash == 64:
            return self.find_sha256(has)
        elif lhash == 128:
            return self.find_sha512(has)

    def find_field(self, f, v):
        return self.session.query(Malware).filter(and_(getattr(Malware, f) == v, Malware.is_sharable(self.user)))

    def find_md5(self, md5):
        return self.find_field('md5', md5).first()

    def find_sha1(self, sha1):
        return self.find_field('sha1', sha1).first()

    def find_sha256(self, sha256):
        return self.find_field('sha256', sha256).first()

    def find_sha512(self, sha512):
        return self.find_field('sha512', sha512).first()

    def find_file_name(self, fn):
        return self.find_field('file_name', fn).all()

    def find_file_size(self, v):
        return self.find_field('file_size', v).all()

    def find_file_type(self, v):
        return self.find_field('file_type', v).all()

    def find_tag(self, tag):
        return self.session.query(Malware).filter(
            and_(Malware.is_sharable(self.user), Malware.tag.any(Tag.tag == tag.lower()))).all()

    def find_ssdeep(self, ssdeep):
        rows = self.session.query(Malware).filter(
            and_(Malware.is_sharable(self.user), Malware.ssdeep.like("%" + str(ssdeep) + "%"))).all()
        return rows

    def find_from(self, frm):
        q = select(['*']).select_from(func.get_sample_from(frm)).filter(Malware.is_sharable(self.user))
        r = []
        for d, h, u in self.session.execute(q):
            v = {'date': d, 'hash': h, 'from': u}
            v['date'] = v['date'].strftime('%s')
            r.append(v)
        return r

    def find_date(self, date):

        date_min = datetime.strptime(date, "%Y-%m-%d")
        date_max = date_min.replace(hour=23, minute=59, second=59)

        rows = self.session.query(Malware).filter(
            and_(Malware.is_sharable(self.user), Malware.created_at >= date_min, Malware.created_at <= date_max)).all()
        return rows

    def list_tags(self):
        return self.session.query(Tag).all()

    def have_similar(self, info):
        r = self.session.query(Malware.ssdeep).filter(and_(Malware.is_sharable(self.user),
                                                           func.fuzzy_hash_compare(Malware.ssdeep,
                                                                                   info.get_ssdeep())) > 95).first()
        return bool(r)

    def add_xref(self, p, c):
        p = self.find_via_hash(p)
        c = self.find_via_hash(c)

        if c and p:
            p.children.append(c)
            self.session.commit()
            return True
        return False

    def add_tag(self, h, t):
        m = self.find_via_hash(h)
        self.tags_append(m, t)
        self.session.commit()

    def add_comment(self, h, cmt):
        p = self.find_via_hash(h)
        p.comment = cmt
        self.session.commit()

    def add_cuckoo(self, h, cid):
        p = self.find_via_hash(h)
        p.cuckoo.append(Cuckoo(cid))
        self.session.commit()

    def add_config(self, h, cfg_hash):
        p = self.find_via_hash(h) if type(h) == str else h
        try:
            p.config = _Config(cfg_hash)
            self.session.commit()
            return

        except IntegrityError as e:
            self.session.rollback()
            self.session.flush()

        try:
            x = self.session.query(_Config).filter(_Config.hash == cfg_hash).first()
            self.session.query(Malware).filter(Malware.id == p.id).update({'config_id': x.id})

            self.session.commit()
            self.session.flush()
        except SQLAlchemyError as e:
            print repr(e)
            self.session.rollback()

    def full_search(self, q):
        return MalwareQuery(q).run(self.session).all()

    def config_samples(self, cfg_hash):
        print cfg_hash, self.user
        cfg = self.session.query(_Config).filter(_Config.hash == cfg_hash).first()
        return filter(lambda m: m.is_sharable(self.user), getattr(cfg, 'mlwr', []))

    def user_samples(self, u=None):
        u = u or self.user
        return self.session.query(Malware).filter(Malware.via.any(Via.via == u)).all()

    def can_cfg_be_shared(self, hash):
        a = self.session.query(_Config).filter(
            and_(_Config.hash == hash, _Config.mlwr.any(Malware.is_sharable(self.user))))
        return self.user in ADMIN_USERS or bool(a.first())

    def get_recent_vtcoms(self):
        return self.session.query(VTComment).order_by(VTComment.date.desc()).limit(100).all()
