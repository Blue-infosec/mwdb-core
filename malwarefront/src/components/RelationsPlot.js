import React, {Component} from 'react';
import ReactDOM from 'react-dom';

import {isEqual} from "lodash";
import * as dagreD3 from "dagre-d3";
import * as d3 from "d3";

import queryString from "query-string";

import api from "@malwarefront/api";
import { capitalize } from "@malwarefront/helpers";

import {Tag} from "./Tag";


class RelationsPlot extends Component {
    state = {
        nodes: null
    }

    constructor(props) {
        super(props);
        this.graph = new dagreD3.graphlib.Graph().setGraph({compound: true})
        this.graph.graph().transition = (selection) => selection.transition().duration(500);
        this.renderer = new dagreD3.render();
    }

    static defaultProps = {
        height: "900",
        width: "100%",
        // width and height are defaulted to 1 due to a FireFox bug(?) If set to 0, it complains.
        fit: true,
        interactive: true
    };

    shouldComponentUpdate(nextProps, nextState) {
        return (
            !isEqual(this.props.nodes, nextProps.nodes) ||
            !isEqual(this.props.edges, nextProps.edges) ||
            !isEqual(this.props.zoom, nextProps.zoom))
    }

    componentDidMount() {
        let nodes;
        if(this.props.hash)
            nodes = [this.props.hash];
        else
            nodes = queryString.parse(this.props.location.search, {arrayFormat: 'bracket'}).node;
        this.setState({nodes}, this.renderDag);
    }

    componentDidUpdate() {
        this.renderDag();
    }

    getHtml = (hash, nodeInfo, expanded) => {
        let tags = nodeInfo.tags;
        let date = nodeInfo.upload_time;
        let type = nodeInfo.type;

        let typeMapping = {
            file: "sample",
            config: "config",
            static_config: "config",
            text_blob: "blob"
        }

        let styleMapping = {
            sample: "bg-danger",
            config: "bg-success",
            blob: "bg-info"

        }

        type = typeMapping[type];
        let d = new Date(date)
        let html = "";

        if (!expanded) {
            html = `<div><div class='mainNode'> 
                        <div class="card" style="width:13rem; cursor: pointer;">
                            <div class="card-header node-header-active ${styleMapping[type]}" style="padding-top: 11px; padding-bottom: 11px;">
                             ${capitalize(type)} <span class="date">${d.toLocaleDateString()}</span></div>
                              <div class="card-body">
                                  <p class="card-text">
                                      <small class="text-muted">
                                            <a href="/${type}/${hash}">
                                                ${hash.substr(0,16)}
                                            </a>
                                      </small>
                                  </p>
                              </div>
                         </div>
                    <div class="card-footer bg-transparent tags" style="max-width: 13rem; white-space:pre-wrap">`;
        } else {
            html = `<div><div class='mainNode'> 
                            <div class="card" style="width:13rem;">
                             <div class="card-header node-header-expanded ${styleMapping[type]}">${capitalize(type)} <span class="date">${d.toLocaleDateString()}</span></div>
                              <div class="card-body">
                                  <a href="/${type}/${hash}">${hash.substr(0,16)}</a><br></div>
                              </div>
                         </div>
                    <div class="card-footer bg-transparent tags" style="max-width: 13rem; white-space:pre-wrap">`;
        }

        tags.forEach((tag)=>{
            let helper = document.createElement("div");
            ReactDOM.render(<Tag tag={tag.tag} searchable={false}/>, helper);
            let tagHTML = helper.innerHTML;

            html += tagHTML;
        });

        html += `</div></div>`;
        return html;
    }

    zoomIdentity() {
        return d3.zoomIdentity.translate(this.nodeTree.parentNode.clientWidth / 2 - 200, this.props.height / 3 - 100)
    }

    async renderDag() {
        try {
            if (this.state.nodes && this.props.history){
                let nodesParam = "node[]=" + this.state.nodes.join("&node[]=");
                this.props.history.replace("/relations?" + nodesParam);
            }

            // Clone current tree view to hide flickering
            let nodeTreeClone = this.nodeTree.cloneNode(true);
            this.container.replaceChild(nodeTreeClone, this.nodeTree);
            this.slave.appendChild(this.nodeTree);

            // Acquire d3 nodes
            let svg = d3.select(this.nodeTree);
            let inner = d3.select(this.nodeTreeGroup);
            
            // Store and reset transform for time of rendering
            let transform = inner.attr("transform");
            if(!transform)
            {
                transform = this.zoomIdentity()
            }
            inner.attr("transform", "")

            if (this.state.nodes)
            {
                await Promise.all(this.state.nodes.map(async (node) => {
                    let objectInfo = await api.getObject("object", node);
                    let nodeInfo = objectInfo.data;

                    let currentHtml = this.getHtml(node, nodeInfo, this.state.nodes.includes(node));
                    this.graph.setNode(node, {labelType:"html", label:currentHtml, class:(this.state.nodes.includes(node) ? "expanded-node" : "not-expanded-node")});

                    await Promise.all(nodeInfo.parents.map(async (parent)=> {
                        let objectInfo = await api.getObject("object", parent.id);
                        let nodeInfo = objectInfo.data;
                        let parentHtml = this.getHtml(parent.id, nodeInfo, this.state.nodes.includes(parent.id));
                        this.graph.setNode(parent.id, {labelType:"html", label:parentHtml, class:(this.state.nodes.includes(parent.id) ? "expanded-node" : "not-expanded-node")});
                        this.graph.setEdge(parent.id, node, {label: "", lineInterpolate: 'basis'});
                    }));

                    await Promise.all(nodeInfo.children.map(async (child)=> {
                        let objectInfo = await api.getObject("object", child.id);
                        let nodeInfo = objectInfo.data;
                        let childHtml = this.getHtml(child.id, nodeInfo, this.state.nodes.includes(child.id));
                        this.graph.setNode(child.id, {labelType:"html", label:childHtml, class:(this.state.nodes.includes(child.id) ? "expanded-node" : "not-expanded-node")});
                        this.graph.setEdge(node, child.id, {label: "", lineInterpolate: 'basis'});
                    }));
                }));
            }

            this.graph.nodes().forEach((v) => {
                let node = this.graph.node(v);

                node.rx = node.ry = 5;
                node.padding = 0;
            });

            this.graph.graph().rankDir = 'LR';

            this.graph.edges().forEach(e => this.graph.edge(e));

            if (this.props.interactive) {
                let zoom = d3.zoom().on("zoom",
                    () => {
                        inner.attr("transform", d3.event.transform + this.zoomIdentity())
                    });
                svg.call(zoom);
            }

            if (this.props.shapeRenderers)
                for (let [shape, renderer] of Object.entries(this.props.shapeRenderers))
                    this.renderer.shapes()[shape] = renderer;

            this.renderer(inner, this.graph);
            
            inner.attr("transform", transform)

            svg.selectAll('.dagre-d3 .node').on('click', id => this.onNodeClick(id));

            svg.attr("height", this.props.height);
            svg.attr("width", this.props.width);

            this.container.replaceChild(this.nodeTree, nodeTreeClone);
        } catch(error) {
            console.error(error);
        }
    }

    onNodeClick = (id) => {
        let nodes = this.state.nodes;
        if (!nodes.includes(id)) {
            nodes.push(id);
            this.setState({nodes}, this.renderDag);
        }
    }

    render() {
        return (
            <div ref={(r) => {this.container = r}}>
                <svg className='dagre-d3' ref={(r) => {this.nodeTree = r}}
                    width={this.props.height}
                    height={this.props.width}>
                    <g ref={(r) => {this.nodeTreeGroup = r}}/>
                </svg>
                <div style={{visibility: "hidden"}} ref={(r) => {this.slave = r}}></div>
            </div>
        );
    }
}

export default RelationsPlot;